// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"

	"sge-monorepo/build/cicd/sgeb/buildtool"
	"sge-monorepo/libs/go/log"

	"sge-monorepo/build/cicd/sgeb/protos/buildpb"
)

const (
	logSleep = 100 * time.Millisecond
)

// TailLogFile opens |logFile| and prints it until the |done| channel is pinged.
func TailLogFile(logFile string, done <-chan struct{}) {
	handle, err := os.Open(logFile)
	// Attempt to open the file until it exists of we're told we're done.
	for err != nil {
		if isDone(done) {
			return
		}
		handle, err = os.Open(logFile)
		time.Sleep(logSleep)
	}
	defer handle.Close()
	// Read the file continuosly until we're singalled we're done.
	offset := int64(0)
	for !isDone(done) {
		time.Sleep(logSleep)
		stat, err := handle.Stat()
		if err != nil {
			continue
		}
		size := stat.Size()
		diff := size - offset
		if diff > 0 {
			var buffer = make([]byte, diff)
			read, err := handle.Read(buffer)
			if err != nil {
				continue
			}
			offset += int64(read)
			// TODO: This might cut log lines, but in general looks fine.
			msg := strings.TrimSpace(string(buffer))
			if msg == "" {
				continue
			}
			// Log per line.
			for _, l := range strings.Split(msg, "\n") {
				log.Debug(l)
			}
		} else if diff < 0 {
			// The file seems to be truncated, we start from the beginning.
			offset = 0
		}
	}
}

// ProcessUnityLogs will go over all the logs generated by unity and create a single log file that's
// the one that sgeb should use to show output.
func ProcessUnityLogs(logsDir string, summaryFile, fullFile *os.File) (*buildpb.Artifact, error) {
	// Summary holds the filtered information. It doesn't always get to run (eg. compilation errors
	// won't even execute the code that generates it), but when it does, we always should prefer it.
	if data, err := ioutil.ReadFile(summaryFile.Name()); err != nil {
		log.Infof("No summary file found: %v", err)
	} else {
		if len(strings.TrimSpace(string(data))) > 0 {
			log.Info("Found summary!")
			return &buildpb.Artifact{
				Tag: "logs",
				Uri: buildtool.LocalFileUri(summaryFile.Name()),
			}, nil
		} else {
			log.Info("Empty summary file")
		}
	}
	// Finally as a last resort, we try to process the full logs.
	return processVerboseLogFile(logsDir, fullFile.Name())
}

// processVerboseLogFile tries to extract relevant information from log output that is in general
// very verbose. We look mostly for compiler output.
func processVerboseLogFile(logsDir, logFile string) (*buildpb.Artifact, error) {
	data, err := ioutil.ReadFile(logFile)
	if err != nil {
		return nil, fmt.Errorf("could not read %q: %v", logFile, err)
	}
	// Search compiler output.
	logCompilerLine := false
	var compilerLines []string
	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		if line == "" {
			continue
		}
		if strings.HasPrefix(line, "-----CompilerOutput:-stdout") {
			logCompilerLine = true
			continue
		}
		if strings.HasPrefix(line, "-----CompilerOutput:-stderr") {
			continue
		}
		if strings.HasPrefix(line, "-----EndCompilerOutput") {
			logCompilerLine = false
			break
		}
		if logCompilerLine {
			compilerLines = append(compilerLines, line)
		}
	}
	// Check if we find relevant compiler. The output will always have a "stderr" separator, so we
	// want output that has one more than that.
	if len(compilerLines) > 1 {
		log, err := ioutil.TempFile(logsDir, "processed_*.log")
		if err != nil {
			return nil, fmt.Errorf("could not create temp log file: %v", err)
		}
		defer log.Close()
		writer := bufio.NewWriter(log)
		for _, line := range compilerLines {
			_, _ = writer.WriteString(line + "\n")
		}
		_ = writer.Flush()
		return &buildpb.Artifact{
			Tag: "logs",
			Uri: buildtool.LocalFileUri(log.Name()),
		}, nil
	}
	// If there is no output, we return this log file as context.
	return &buildpb.Artifact{
		Tag: "logs",
		Uri: buildtool.LocalFileUri(logFile),
	}, nil
}

func isDone(done <-chan struct{}) bool {
	select {
	case <-done:
		return true
	default:
		return false
	}
}
