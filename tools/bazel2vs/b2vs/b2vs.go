// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package b2vs is a command line application used to generate a visual studio solution from bazel.
// Editing, debugging and building can be done from the generated visual studio.
// bazel2vs should from a bazel rule: bazel build //my/package:msbuild_target
package b2vs

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"

	"sge-monorepo/build/cicd/bep"
	"sge-monorepo/build/cicd/monorepo"

	bepb "bazel.io/src/main/java/com/google/devtools/build/lib/buildeventstream/proto"
)

const (
	projectTypeGUID     = "{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}" // GUID that identify a project in a VS solution
	defaultSolutionName = "sge"
)

// B2VSConfig hold the arguments passed from the command line.
type Config struct {
	OutputDir      string   // Ouput directory of bazel2vs. Location of the solution written on disk.
	SolutionName   string   // Name of the .sln file created by bazel2vs.
	Targets        []string // list of bazel targets.
}

// buildConfig contains the name of a build configuration for msbuild and bazel
// As an example, the build config debug is called "Debug" by msbuild and "dbg" by bazel
type buildConfig struct {
	msbuildName string
	bazelName   string
}

// platform contains the name of a platform for msbuild and bazel
// As an example, the platform Windows x64 is called "x64" by msbuild and x64_windows by bazel
type platform struct {
	msbuildName  string
	bazelName    string
	bazelCfgName string
	debuggerName string
}

// context holds the revelant information of generate a solution.
type context struct {
	outputSlnDir   string             // Output directory of bazel2vs. Where the .sln will be located.
	solutionName   string             // Name of the .sln file outputed by bazel2vs
	buildCfg       []buildConfig      // List of build configuration supported
	platforms      []platform         // List of platform supported
	execRoot       string             // Execution root of bazel workspace
	monorepo       *monorepo.Monorepo // Monorepo is a monorepo root + the repo map. monorepo is kept in the context because the repo map is need to map external file to the correct path in the monorepo.
	bazel          string             // Absolute path to bazel.exe
}

// bazelExecRoot invokes bazel to get the path to the execution root.
func bazelExecRoot(ctx *context) (string, error) {
	output, err := exec.Command(ctx.bazel, "info", "execution_root").Output()
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(output)), nil
}

// newContext creates a context from a visual studio config.
func newContext(cfg *Config) (*context, error) {
	var ctx context
	// supported build configurations
	ctx.buildCfg = []buildConfig{
		{"FastBuild", "fastbuild"},
		{"Debug", "dbg"},
		{"Release", "opt"},
	}
	// supported platforms
	ctx.platforms = []platform{
		{"x64", "x64_windows", "windows", "WindowsLocalDebugger"},
		{"linux", "x64_linux", "ubuntu", "WindowsLocalDebugger"},
	}
	if cfg.SolutionName != "" {
		ctx.solutionName = cfg.SolutionName
	} else {
		ctx.solutionName = defaultSolutionName
	}
	// init paths. bazel2vs expects to be executed from a monorepo.
	mr, _, err := monorepo.NewFromPwd()
	if err != nil {
		return nil, err
	}
	ctx.monorepo = &mr
	ctx.outputSlnDir = filepath.Join(mr.Root, cfg.OutputDir)
	// retrieve the location of bazel.exe
	bazelwsp, err := mr.NewPath("", "//bin/windows/bazel.exe")
	if err != nil {
		return nil, err
	}
	ctx.bazel = mr.ResolvePath(bazelwsp)
	ctx.execRoot, err = bazelExecRoot(&ctx)
	if err != nil {
		return nil, err
	}
	return &ctx, nil
}

// buildInvocationResult return an array of paths to the msbuild files generated by the bazel build command.
func buildInvocationResult(s *bep.Stream) ([]string, error) {
	var fileSets []*bepb.BuildEventId_NamedSetOfFilesId
	for _, be := range s.Events {
		switch be.Id.Id.(type) {
		case *bepb.BuildEventId_TargetCompleted:
			tce, ok := be.Payload.(*bepb.BuildEvent_Completed)
			success := ok && tce.Completed.Success
			if !success {
				return nil, fmt.Errorf("build event did not completed successfully")
			}
			tc := tce.Completed
			for _, outputGroup := range tc.OutputGroup {
				// We only care about the msbuild_outputs output group.
				// We do not issue build commands with output groups other than the msbuild_outputs.
				if outputGroup.Name == "msbuild_outputs" {
					fileSets = append(fileSets, outputGroup.FileSets...)
				}
			}
		}
	}
	var results []string
	for _, f := range s.Depsets.Files(fileSets) {
		uri := f.File.(*bepb.File_Uri)
		if !strings.HasPrefix(uri.Uri, "file:///") {
			return nil, fmt.Errorf("%s uri should begin with prefix file:///", uri)
		}
		results = append(results, strings.TrimPrefix(uri.Uri, "file:///"))
	}
	// Make sure the order is deterministic.
	sort.Strings(results)
	return results, nil
}

// generateTargetInfo run a bazel build commmand to generate TargetInfo proto buffers.
// build event protocol is use to retrieve the location of the protobufs.
// Those TargetInfo protobufs will be used to generate VS projects.
func generateTargetInfo(ctx *context, pkgs []string) ([]string, error) {
	// build event output will written to this file.
	tempFile, err := ioutil.TempFile("", "bep*.out")
	if err != nil {
		return nil, err
	}
	defer os.Remove(tempFile.Name())

	args := []string{
		"build",
		"--aspects=@aspect_msbuild//:msbuild.bzl%msbuild_aspect",
		"--output_groups=msbuild_outputs",
		"--build_event_binary_file=" + tempFile.Name(),
	}
	args = append(args, pkgs...)
	// Invocation of bazel build to generate targetInfo.
	// A bep.out file will be generated.
	output, err := exec.Command(ctx.bazel, args...).CombinedOutput()
	if err != nil {
		log.Println(string(output))
		return nil, err
	}
	// read and parse bep.out
	content, err := ioutil.ReadAll(tempFile)
	if err != nil {
		return nil, err
	}
	bepStream, err := bep.Parse(content)
	if err != nil {
		return nil, err
	}
	results, err := buildInvocationResult(bepStream)
	if err != nil {
		return nil, err
	}
	// If the output of the bazel build command is already up-to-date, no build event are generated.
	// This mean the solution is already up to date.
	if len(results) == 0 {
		return nil, fmt.Errorf("the solution is already up-to-date")
	}
	return results, nil
}

// GenerateVSSolution generates a complete VS solution and write it on disk.
func GenerateVSSolution(cfg *Config) (string, error) {
	ctx, err := newContext(cfg)
	if err != nil {
		return "", err
	}
	targetInfos, err := generateTargetInfo(ctx, cfg.Targets)
	if err != nil {
		return "", err
	}
	projInfos, err := generateProjects(ctx, targetInfos)
	if err != nil {
		return "", err
	}
	return generateSolution(ctx, projInfos)
}
