// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package b2vs

import (
    "embed"
	"fmt"
	"io/ioutil"
    "log"
	"os"
	"path/filepath"
    "runtime/debug"
	"sort"
	"strings"

	"sge-monorepo/tools/bazel2vs/protos/msbuildpb"

	"github.com/golang/protobuf/proto"
	gouuid "github.com/nu7hatch/gouuid"
)

// Embedded resources.
//go:embed templates/*
var templates embed.FS

func readTemplate(template string) string {
    data, err := templates.ReadFile(template)
    if err != nil {
        debug.PrintStack()
        log.Fatalf("could not find template %q", template)
    }
    return string(data)
}

func ReadTemplate(template string) string {
    return readTemplate(template)
}

// The output path generated by the aspect is always under the build config directory "x64_windows-fastbuild".
// To get a valid path regardless of the build config, "x64_windows-fastbuild" is replaced by $(BazelCfgDirname).
// $(BazelCfgDirname) is a variable in the .vcxproj file that we define and correspond to the right build config directory name.
var pathReplacer *strings.Replacer = strings.NewReplacer("x64_windows-fastbuild", "$(BazelCfgDirname)")

//projectOutput data necessary to output a project file.
type projectOutput struct {
	execPath      string // path to the executable output of the project. Can be empty if the project does not generate an executable.
	execName      string // name of the exectutable generated by the project. Can be empty if the project does not generate an executable.
	workspaceRoot string // path to the root of the bazel workspace.
	projectName   string // Name of the project displayed by VS
	vcxprojDir    string // output directory of the vcxproj and vcxproj.filters files.
	uuid          string // uuid of the project for VS.
}

// projectInfo the info necessary to build a visual studio project file.
type projectInfo struct {
	targetInfo *msbuildpb.TargetInfo
	output     projectOutput // Output of the project. Only support 1 output at the moement.
}

// generateUUIDFromString generates an UUID from string. The same string should always
// returns the same UUID
func generateUUIDFromString(data string) (string, error) {
	uuid, err := gouuid.NewV5(gouuid.NamespaceURL, []byte(data))
	if err != nil {
		return "", err
	}
	return fmt.Sprintf("{%s}", strings.ToUpper(uuid.String())), nil
}

// projectName returns a valid VS project name from a label.
func projectName(l *msbuildpb.Label) string {
	name := l.Name
	if l.WorkspaceName != "" {
		name = "@" + l.WorkspaceName + "//" + name
	}
	return name
}

// projOutputDir returns the output directory for the project files.
// The output directory will under WorkspaceRoot/Label.Pkg.
func projOutputDir(l *msbuildpb.Label) string {
	return filepath.Join(l.WorkspaceRoot, l.Pkg)
}

// newProjectInfo create a projetInfo from a targetInfo protobuf.
func newProjectInfo(ctx *context, ti *msbuildpb.TargetInfo) (*projectInfo, error) {
	proj := projectInfo{
		targetInfo: ti,
		output: projectOutput{
			workspaceRoot: ctx.monorepo.Root,
			projectName:   projectName(ti.Label),
			vcxprojDir:    filepath.Join(ctx.outputSlnDir, projOutputDir(ti.Label)),
		},
	}
	var err error
	proj.output.uuid, err = generateUUIDFromString(ti.Label.Label)
	if err != nil {
		return nil, err
	}
	// The path and the name of an executable is necessary to attach a debugger.
	// A target is assumed to output at most 1 executable. The first output with an .exe or .dll extension will be used.
	for _, output := range ti.Outputs {
		outputExt := filepath.Ext(output.Path)
		if outputExt == ".exe" || outputExt == ".dll" {
			proj.output.execName = filepath.Base(output.Path)
			exeDir := filepath.Dir(output.Path)
			proj.output.execPath = pathReplacer.Replace(filepath.Join(ctx.execRoot, exeDir))
			break
		}
	}
	return &proj, nil
}

// readTargetInfo reads targetInfo protobuf
func readTargetInfo(filename string) (*msbuildpb.TargetInfo, error) {
	f, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	targetInfo := &msbuildpb.TargetInfo{}
	if err := proto.UnmarshalText(string(f), targetInfo); err != nil {
		return nil, err
	}
	return targetInfo, nil
}

// lines concatenates string element together with the "\r\n" separator.
func lines(lines ...string) string {
	return strings.Join(lines, "\r\n")
}

// msbProjectCfgs generates content of a XML <ProjectConfiguration> tag for a .vcxproj file.
func msbProjectCfgs(ctx *context) string {
	var msConfigs []string
	for _, buildcfg := range ctx.buildCfg {
		for _, platform := range ctx.platforms {
			projectCfg := lines(``,
				fmt.Sprintf(`    <ProjectConfiguration Include="%s|%s">`, buildcfg.msbuildName, platform.msbuildName),
				fmt.Sprintf(`      <Configuration>%s</Configuration>`, buildcfg.msbuildName),
				fmt.Sprintf(`      <Platform>%s</Platform>`, platform.msbuildName),
				`    </ProjectConfiguration>`,
			)
			msConfigs = append(msConfigs, projectCfg)
		}
	}
	return strings.Join(msConfigs, "")
}

// msbCfgProperties generates content of a XML <PropertyGroup> tag for a .vcxproj file.
func msbCfgProperties(ctx *context, info *projectInfo) string {
	var props []string
	for _, buildcfg := range ctx.buildCfg {
		for _, platform := range ctx.platforms {
			buildName := platform.bazelName + "-" + buildcfg.bazelName
			property := lines(``,
				fmt.Sprintf(`  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='%s|%s'">`, buildcfg.msbuildName, platform.msbuildName),
				fmt.Sprintf(`    <BazelCfgOpts>-c %s --config=%s</BazelCfgOpts>`, buildcfg.bazelName, platform.bazelCfgName),
				fmt.Sprintf(`    <BazelCfgDirname>%s</BazelCfgDirname>`, buildName),
				fmt.Sprintf(`    %s`, msbNMakeOutput(info, platform.msbuildName)),
				fmt.Sprintf(`    %s`, msbTargetNameExt(info, platform.msbuildName)),
				`  </PropertyGroup>`,
			)
			props = append(props, property)
		}
	}
	return strings.Join(props, "")
}

// msbCfgDebuggerWorkingDirectory generates content of a XML <LocalDebuggerWorkingDirectory> tag for a .vcxproj.user file.
func msbCfgDebuggerWorkingDirectory(ctx *context, info *projectInfo) string {
	var props []string
	for _, platform := range ctx.platforms {
		property := lines(``,
			fmt.Sprintf(`  <PropertyGroup Condition="'$(Platform)'=='%s'">`, platform.msbuildName),
			fmt.Sprintf(`    <LocalDebuggerWorkingDirectory>%s</LocalDebuggerWorkingDirectory>`, info.output.workspaceRoot),
			fmt.Sprintf(`    <DebuggerFlavor>%s</DebuggerFlavor>`, platform.debuggerName),
			`  </PropertyGroup>`,
		)
		props = append(props, property)
	}
	return strings.Join(props, "")
}

// appendDirs appends a directory to a set then recursively appends the path to the directory.
func appendDirs(filters map[string]bool, directory string) {
	if directory == "" || directory == "." {
		return
	}
	directory = filepath.Clean(directory)
	if filters[directory] {
		return
	}
	for filters[directory] = true; directory != "."; directory = filepath.Dir(directory) {
		filters[directory] = true
	}
}

// msbFileFilter generates content of a XML <Filter> tag for a .vcxproj.filters file.
func msbFileFilter(ctx *context, info *projectInfo, file *msbuildpb.File, filters map[string]bool) (string, bool) {
	// In most cases, files in a package are in the same directory as that package.
	// If they are in another directory, we add a filter to the file to help
	// keep things organized the same way they are in the codebase.
	dir := filepath.Dir(file.ShortPath)
	if dir == "" || dir == "." {
		return "", false
	}
	var filter string
	var err error
	// If there is a package name. the relative path from the directory of the file to the package will be used as filter.
	// example:
	// file: /experimental/my/pkg/src/main.cpp
	// pkg: experimental/my/pkg
	// filter: src
	// If the package name is empty, the relative path from the directory of the file to the repo path will be used as filter.
	// This approach results in deeper filters, but this is the best we can do in the current situation.
	if info.targetInfo.Label.Pkg == "" {
		repoPath := filepath.Join(ctx.monorepo.Root, string(ctx.monorepo.RepoPath(file.OwnerWorkspaceName)))
		filePath := filepath.Join(repoPath, filepath.Dir(file.ShortPath))
		filter, err = filepath.Rel(repoPath, filePath)
	} else {
		filter, err = filepath.Rel(info.targetInfo.Label.Pkg, dir)
	}
	if err != nil {
		return "", false
	}
	// Paths from external workspakce will generated a path starting with "..\".
	for strings.HasPrefix(filter, `..\`) {
		filter = strings.TrimPrefix(filter, `..\`)
	}
	if filter == "" || filter == "." {
		return "", false
	}
	appendDirs(filters, filter)
	return fmt.Sprintf("<Filter>%s</Filter>", filter), true
}

// resolveFilePath takes a file path and returns the absolute path to the file.
// It takes into account files owned by the main workspace, generated files and
// files owned by external workspaces.
func resolveFilePath(ctx *context, info *projectInfo, file *msbuildpb.File) string {
	// generated files have a build config specific path.
	if file.RootPath != "" {
		return pathReplacer.Replace(filepath.Join(ctx.execRoot, file.Path))
	}
	// Files own by an external workspace are copied to the external folder under the execution root.
	// To be able to edit the file form VS, the path to the orignal file is needed.
	repoPath := ctx.monorepo.RepoPath(file.OwnerWorkspaceName)
	return filepath.Join(ctx.monorepo.Root, string(repoPath), file.ShortPath)
}

// itemGroupGenerator returns an XML <ItemGroup> tag and set of filters.
type itemGroupGenerator func(*context, *projectInfo, *msbuildpb.File, map[string]bool) string

// msbCCSrc generates content of a XML <ClCompile> tag for a .vcxproj file.
func msbCCSrc(ctx *context, info *projectInfo, file *msbuildpb.File, outFilters map[string]bool) string {
	if file.ShortPath == "" {
		return ""
	}
	return fmt.Sprintf("<ClCompile Include=\"%s\"></ClCompile>", resolveFilePath(ctx, info, file))
}

// msbCCSrcFilter generates content of a XML <ClCompile> tag for a .vcxproj.filters file and the corresponding filter.
func msbCCSrcFilter(ctx *context, info *projectInfo, file *msbuildpb.File, outFilters map[string]bool) string {
	if file.ShortPath == "" {
		return ""
	}
	filter, shouldContinue := msbFileFilter(ctx, info, file, outFilters)
	if !shouldContinue {
		return ""
	}
	return fmt.Sprintf("<ClCompile Include=\"%s\">%s</ClCompile>", resolveFilePath(ctx, info, file), filter)
}

// msbCCInc generates content of a XML <ClInclude> tag for a .vcxproj.
func msbCCInc(ctx *context, info *projectInfo, file *msbuildpb.File, outFilters map[string]bool) string {
	if file.ShortPath == "" {
		return ""
	}
	return fmt.Sprintf("<ClInclude Include=\"%s\"></ClInclude>", resolveFilePath(ctx, info, file))
}

// msbCCIncFilter generates content of a XML <ClInclude> tag for a .vcxproj.filters and the corresponding filter.
func msbCCIncFilter(ctx *context, info *projectInfo, file *msbuildpb.File, outFilters map[string]bool) string {
	if file.ShortPath == "" {
		return ""
	}
	// During generation of .vcxproj file, we don't include filters info. Only for .vcxproj.filters
	filter, shouldContinue := msbFileFilter(ctx, info, file, outFilters)
	if !shouldContinue {
		return ""
	}
	return fmt.Sprintf("<ClInclude Include=\"%s\">%s</ClInclude>", resolveFilePath(ctx, info, file), filter)
}

// msbNoneSrc generates content of a XML <None> tag for a .vcxproj file.
func msbNoneSrc(ctx *context, info *projectInfo, file *msbuildpb.File, outFilters map[string]bool) string {
	if file.ShortPath == "" {
		return ""
	}
	return fmt.Sprintf("<None Include=\"%s\"></None>", resolveFilePath(ctx, info, file))
}

// msbNoneSrcFilter generates content of a XML <None> tag for a .vcxproj.filters file and the corresponding filter.
func msbNoneSrcFilter(ctx *context, info *projectInfo, file *msbuildpb.File, outFilters map[string]bool) string {
	if file.ShortPath == "" {
		return ""
	}
	filter, shouldContinue := msbFileFilter(ctx, info, file, outFilters)
	if !shouldContinue {
		return ""
	}
	return fmt.Sprintf("<None Include=\"%s\">%s</None>", resolveFilePath(ctx, info, file), filter)
}

// msbFilterItems generates content of a XML <Filter> tag for a .vcxproj.filters file.
func msbFilterItems(filters map[string]bool) (string, error) {
	var paths []string
	for k := range filters {
		paths = append(paths, k)
	}
	sort.Strings(paths)
	var tags []string
	for _, path := range paths {
		uuid, err := generateUUIDFromString(path)
		if err != nil {
			return "", err
		}
		tag := fmt.Sprintf(
			"\r\n    <Filter Include=\"%s\">"+
				"\r\n      <UniqueIdentifier>%s</UniqueIdentifier>"+
				"\r\n    </Filter>", path, uuid)
		tags = append(tags, tag)
	}
	return strings.Join(tags, "\r\n"), nil
}

// msbItemGroup generates content of a XML <ItemGroup> tag for a .vcxproj file or a .vcxproj.filters file.
// It also populate the set of filters for the files provided.
func msbItemGroup(ctx *context, info *projectInfo, outFilters map[string]bool, fileTargets []*msbuildpb.File, fun itemGroupGenerator) string {
	if len(fileTargets) == 0 || fun == nil {
		return ""
	}
	var xmlItems []string
	for _, file := range fileTargets {
		item := fun(ctx, info, file, outFilters)
		if item != "" {
			xmlItems = append(xmlItems, item)
		}
	}
	items := strings.Join(xmlItems, "\r\n    ")
	return fmt.Sprint(
		"\r\n  <ItemGroup>" +
			"\r\n    " + items +
			"\r\n  </ItemGroup>")
}

// isRust returns true if the kind is rust related.
func isRust(info *projectInfo) bool {
	return info.targetInfo.Rust != nil
}

// IsCc returns true if the kind is Cc related.
func isCc(info *projectInfo) bool {
	return info.targetInfo.Cc != nil
}

// Remove duplicated files. Return the list of hdrs files not included in the list of srcs files.
// If a file is included both as srcs and hdrs, it is removed from hdrs. If not, the project will fail to load.
func removeDuplicatedFiles(hdrs, srcs []*msbuildpb.File) []*msbuildpb.File {
	m := make(map[string]bool)
	for _, s := range srcs {
		m[s.Path] = true
	}
	var uniqueHdrs []*msbuildpb.File
	for _, h := range hdrs {
		if _, ok := m[h.Path]; !ok {
			uniqueHdrs = append(uniqueHdrs, h)
		}
	}
	sort.Slice(uniqueHdrs, func(i, j int) bool { return uniqueHdrs[i].Path < uniqueHdrs[j].Path })
	return uniqueHdrs
}

// msbFiles gathers the list of source and header files for the project. It also populate the set of filters
// of the project.
func msbFiles(ctx *context, info *projectInfo, outFilters map[string]bool, includeFilter bool) string {
	hdrs := removeDuplicatedFiles(info.targetInfo.Files.Hdrs, info.targetInfo.Files.Srcs)
	// Get the right <ItemGroup> generator depending on the language.
	var srcGenerator, hdrGenerator itemGroupGenerator
	if isCc(info) {
		if includeFilter {
			srcGenerator = msbCCSrcFilter
			hdrGenerator = msbCCIncFilter
		} else {
			srcGenerator = msbCCSrc
			hdrGenerator = msbCCInc
		}
	} else if isRust(info) {
		if includeFilter {
			srcGenerator = msbNoneSrcFilter
		} else {
			srcGenerator = msbNoneSrc
		}
	}
	return msbItemGroup(ctx, info, outFilters, info.targetInfo.Files.Srcs, srcGenerator) +
		msbItemGroup(ctx, info, outFilters, hdrs, hdrGenerator)
}

// targetNameAndExt returns (name,ext) for the given platform from the path of the windows binary
func targetNameAndExt(winBinary, platform string) (string, string) {
	extWin := filepath.Ext(winBinary)
	name := strings.TrimSuffix(winBinary, extWin)
	targetExt := ""
	if platform == "x64" {
		targetExt = extWin
	} else {
		if extWin == ".dll" {
			targetExt = ".so"
		} else {
			targetExt = ""
		}
	}
	targetExt = strings.TrimPrefix(targetExt, ".")
	return name, targetExt
}

// msbTargetNameExt generates content of a XML <TargetName> tag for a .vcxproj file.
func msbTargetNameExt(info *projectInfo, platform string) string {
	if info.output.execName == "" {
		return ""
	}

	name, ext := targetNameAndExt(info.output.execName, platform)
	return fmt.Sprintf("<TargetName>%s</TargetName><TargetExt>%s</TargetExt>", name, ext)
}

// msbNMakeOutput generates content of a XML <NMakeOutput> tag for a .vcxproj file.
func msbNMakeOutput(info *projectInfo, platform string) string {
	if info.output.execName == "" {
		return ""
	}
	name, ext := targetNameAndExt(info.output.execName, platform)
	execName := name
	if ext != "" {
		execName += "." + ext
	}
	return fmt.Sprintf(
		"<NMakeOutput>%s</NMakeOutput>",
		filepath.Join(info.output.execPath, execName))
}

// appendStrings return a unique set of strings from a slice of strings.
// The string "." is not added to the set.
func appendStrings(strs []string, set map[string]bool) {
	for _, str := range strs {
		if str == "." {
			continue
		}
		set[str] = true
	}
}

// joinIncludeDirs gathers all include paths, removes duplicated, sorted them and join them into a string.
func joinIncludeDirs(ctx *context, info *projectInfo) string {
	if !isCc(info) {
		return ""
	}
	// Gather all include paths and make sure they are unique
	includeDirSet := make(map[string]bool)
	appendStrings(info.targetInfo.Cc.IncludeDirs, includeDirSet)
	appendStrings(info.targetInfo.Cc.QuoteIncludeDirs, includeDirSet)
	appendStrings(info.targetInfo.Cc.SystemIncludeDirs, includeDirSet)
	var allAbsIncludeDirs []string
	for dir := range includeDirSet {
		dir = filepath.Join(ctx.execRoot, dir)
		dir = pathReplacer.Replace(dir)
		allAbsIncludeDirs = append(allAbsIncludeDirs, dir)
	}
	// Add the root of the monorepo to the include directory set.
	allAbsIncludeDirs = append(allAbsIncludeDirs, filepath.Clean(ctx.monorepo.Root))
	sort.Strings(allAbsIncludeDirs)
	return strings.Join(allAbsIncludeDirs, ";")
}

func joinDefines(info *projectInfo) string {
	if !isCc(info) {
		return ""
	}
	return strings.Join(info.targetInfo.Cc.Defines, " ")
}

// generateProjectUser modifies a template to generate the content of a .vcxproj.user file
func generateProjectUser(ctx *context, info *projectInfo) string {
	r := strings.NewReplacer(
		"{debug_working_dir}", msbCfgDebuggerWorkingDirectory(ctx, info),
	)
    return r.Replace(readTemplate("templates/vcxproj.user.xml"))
}

// generateProjectFilters modifies a template to generate the content of a .vcxproj.filters file
func generateProjectFilters(ctx *context, info *projectInfo) (string, error) {
	filters := make(map[string]bool)
	files := msbFiles(ctx, info, filters, true) // generate filters for msbFilterItems
	items, err := msbFilterItems(filters)
	if err != nil {
		return "", err
	}
	filterReplacer := strings.NewReplacer(
		"{file_groups}", files,
		"{filter_items}", items,
	)
	return filterReplacer.Replace(readTemplate("templates/vcxproj.filters.xml")), nil
}

// generateProjectFile modifies a template to generate the content of a .vcxproj file
func generateProjectFile(ctx *context, info *projectInfo, projectCfg string) string {
	r := strings.NewReplacer(
		"{cfg.bazel_path}", ctx.bazel,
		"{project_name}", info.output.projectName,
		"{target.label.absolute}", info.targetInfo.Label.Label,
		"{target.guid}", info.output.uuid,
		"{target.defines_joined}", joinDefines(info),
		"{project_configs}", projectCfg,
		"{config_properties}", msbCfgProperties(ctx, info),
		"{out_dir}", info.output.execPath,
		"{file_groups}", msbFiles(ctx, info, map[string]bool{}, false),
		"{working_directory}", ctx.monorepo.Root,
		"{include_dirs_joined}", joinIncludeDirs(ctx, info),
	)
	return r.Replace(readTemplate("templates/vcxproj.xml"))
}

// generateProjects takes as input a context and a list of msbuild filenames.
// From the content of each msbuild files, 3 projects files are generated
// 1 .vcxproj, 1 .vcxproj.filters and 1 .vcxproj.user files.
// Finally, project infos are returned to be used as input for the generation of the solution.
func generateProjects(ctx *context, msbuildFilenames []string) ([]*projectInfo, error) {
	projectCfg := msbProjectCfgs(ctx)
	var infos []*projectInfo
	for _, filename := range msbuildFilenames {
		content, err := readTargetInfo(filename)
		if err != nil {
			return nil, err
		}
		info, err := newProjectInfo(ctx, content)
		if err != nil {
			return nil, err
		}
		// Create a folder for the project files
		err = os.MkdirAll(info.output.vcxprojDir, os.ModePerm)
		if err != nil {
			return nil, err
		}
		infos = append(infos, info)
		err = ioutil.WriteFile(filepath.Join(info.output.vcxprojDir, info.targetInfo.Label.Name+".vcxproj"), []byte(generateProjectFile(ctx, info, projectCfg)), os.ModePerm)
		if err != nil {
			return nil, err
		}
		filterContent, err := generateProjectFilters(ctx, info)
		if err != nil {
			return nil, err
		}
		err = ioutil.WriteFile(filepath.Join(info.output.vcxprojDir, info.targetInfo.Label.Name+".vcxproj.filters"), []byte(filterContent), os.ModePerm)
		if err != nil {
			return nil, err
		}
		// .vcxproj.user is needed because <LocalDebuggerWorkingDirectory> is sometime not taken into account if present in the .vcxproj file
		// see: https://developercommunity.visualstudio.com/content/problem/268817/debugger-no-longer-respects-localdebuggerworkingdi.html?childToView=1057350#comment-1057350
		err = ioutil.WriteFile(filepath.Join(info.output.vcxprojDir, info.targetInfo.Label.Name+".vcxproj.user"), []byte(generateProjectUser(ctx, info)), os.ModePerm)
		if err != nil {
			return nil, err
		}
	}
	return infos, nil
}
